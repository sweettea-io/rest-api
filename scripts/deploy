#!/bin/bash

# --- Deploy supported application to Kubernetes cluster of specified env tier --- #

# ======== PARSE ARGS ======== #

this_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
app="$1"
deploy_env="$2"

# ======== VALIDATE ARGS ======== #

$this_dir/validate_arg "target" "$app" "server|migrate|worker"
$this_dir/validate_arg "env" "$deploy_env" "local|dev|staging|prod"

# ======== TAG/PUSH IMAGE TO REPOSITORY ======== #

image_owner=$( $this_dir/env_reader "$app" "$deploy_env" "IMAGE_OWNER" )
image_name=$( $this_dir/env_reader "$app" "$deploy_env" "IMAGE_NAME" )
image_repo="$image_owner/$image_name"
image_version=$( $this_dir/latest_sha )

# Tag Docker image with version of latest commit sha.
docker tag "$image_name" "$image_repo:$image_version"

# Push Docker image to external repository.
docker push "$image_repo:$image_version"

# ======== SPECIFY/VALIDATE CLUSTER ======== #

# Get cluster name from envs.
cluster_name=$( $this_dir/env_reader "$app" "$deploy_env" "CLUSTER_NAME" )

# Switch to cluster context.
kubectl config use-context "$cluster_name"

if ! kubectl get nodes; then
	echo "Error fetching cluster nodes. Not deploying."
	exit
fi

# ======== DETERMINE DEPLOYMENT EXISTENCE ======== #

resource_name="$image_name"	# unique suffix will be added for job deploys

# Always make a new deploy for deploys that are actually 'jobs' (i.e. migrate jobs)
if [[ "$app" = "migrate" ]]; then
	new_deploy="true"

	# For a job, the resource name needs to differ with each deploy, so generate a uuid for suffix.
	uuid=$( uuidgen )
	job_uuid="${uuid:0:8}"
	image_name="$image_name-$job_uuid"
else
	# TODO: For 'deployments', check to see if they already exist first.
	# This will determine whether we should 'kubectl run' or simply 'kubectl set image'.
	echo "TODO"
fi

# ======== FORMAT DEPLOY ARGS ======== #

port=$( $this_dir/env_reader "$app" "$deploy_env" "SERVER_PORT" "port" )
replicas=$( $this_dir/env_reader "$app" "$deploy_env" "REPLICAS_COUNT" "replicas" )
restart=$( $this_dir/env_reader "$app" "$deploy_env" "RESTART_POLICY" "restart" )
deploy_envs=$( $this_dir/env_reader "$app" "$deploy_env" "all" "true" )

# ======== DEPLOY ======== #

if [[ "$new_deploy" ]]; then
	# Create a new k8s cluster deployment.
	kubectl run "$resource_name" "--image=$image_repo" "$port" "$replicas" "$restart" "$deploy_envs"
else
	# Update the image of an existing k8s deployment.
	kubectl set image "deployment/$resource_name" "$image_name=$image_repo:$image_version"
fi

echo "Done!"